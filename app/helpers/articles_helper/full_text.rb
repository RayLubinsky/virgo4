# app/helpers/articles_helper/full_text.rb
#
# frozen_string_literal: true
# warn_indent:           true

__loading_begin(__FILE__)

# Methods to support the display of EBSCO EDS fulltext.
#
module ArticlesHelper::FullText

  include HtmlHelper

  def self.included(base)
    __included(base, '[ArticlesHelper::FullText]')
  end

  # CSS class denoting an element generated by this method.
  #
  # @type [String]
  #
  EBSCO_GENERATED = 'generated'

  # Options for elements added by this logic.
  #
  # @type [Hash{Symbol=>Object}]
  #
  EBSCO_OPTS = { class: EBSCO_GENERATED }

  # Ignore certain spacing characters.
  #
  # @type [Array<String>]
  #
  EBSCO_REMOVE_CHARS = %W(\u0085 \u00a0).freeze

  # Ignore certain spacing characters.
  #
  # @type [Regexp]
  #
  # @see self#render_fulltext
  #
  EBSCO_REMOVE_CHARS_REGEX = /[#{EBSCO_REMOVE_CHARS.join}]/

  # Characters that start a new line in the fulltext display.
  #
  # @type [Array<String>]
  #
  EBSCO_BREAK_BEFORE = %w(• ‣ ◘ ◦).freeze

  # Characters that start a new line in the fulltext display.
  #
  # @type [Regexp]
  #
  # @see self#render_fulltext
  #
  EBSCO_BREAK_BEFORE_REGEX = /\s+(#{EBSCO_BREAK_BEFORE.join('|')})(\s+)/

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Enhance fulltext content
  #
  # @param [String, Array<String>]    content
  # @param [Hash, nil]                opt
  #
  # @options opt [String] :separator  Used to join *content* elements;
  #                                     default: '<br/>'.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  # @see self#render_fulltext_references!
  # @see self#render_fulltext_links!
  #
  # === Examples
  #
  # @example Typical (with <anid>, <title>, <sbt>, <hd>, <aug>)
  #   /articles/eft__527588351
  #
  # @example With <ulist>, <hd1>, <ephtml>, <blist>, <bibtext>
  #   /articles/ehh__119126750
  #
  # @example With uneven tables due to the delivered content
  #   /articles/eft__133590749
  #
  # @example With shaded table cells in the delivered content
  #   /articles/a9h__133661705
  #
  # @example With colored table cells in the delivered content
  #   /articles/a9h__133745021
  #   /articles/a9h__133745052
  #
  # @example With <olist>
  #   /articles/eft__527588340
  #
  # @example With <ct>
  #   /articles/eft__527588340
  #
  # @example With <img>
  #   /articles/f5h__32045913
  #
  # @example With <et>, <rj>
  #   /articles/f5h__118200455
  #
  def render_fulltext(content, opt = nil)
    separator = opt && opt[:separator] || '<br/>'
    content   = Array.wrap(content).join(separator)

    # === Clean out certain characters
    content.gsub!(EBSCO_REMOVE_CHARS_REGEX, '')

    # === Superscript/subscript adjust
    # Found in <ephtml> tables; e.g. "[sub 2]" or "[sup -9]":
    content.gsub!(/\[(sub|sup)\s*([^\]]+)\s*\]/) { ft_tag($1, $2) }

    # === Table corrections
    # Eliminate line breaks that somehow crop up inside <ephtml> tables.
    content.gsub!(%r{(tbody>|tr>|td>)<\s*br\s*/?>}i, '\1')

    # === Line breaks
    # Insert a break before certain characters like bullets.
    content.gsub!(EBSCO_BREAK_BEFORE_REGEX) { ['<br/>', $1, $2].join }

    # === Finalize line breaks
    # Breaks usually indicate a gap; a single break won't accomplish that but
    # an empty paragraph will.
    content.gsub!(%r{(\s*<br\s*/?>\s*)+}, '<p></p>')

    # === Apply other modifications and return the display-ready content
    render_fulltext_references!(content)
    render_fulltext_links!(content)
    content.html_safe
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # === Fix bogus <reflink> elements
  # @type [Regexp]
  BOGUS_REFLINK_REGEX = %r{
    ([(,;]?)                          # Open paren or punctuation          ($1)
      <(reflink)[^>]*>                # Open tag                           ($2)
        (.*?)                         # Note number                        ($3)
      </\s*\2\s*>                     # Close tag
    ([),;]?)                          # Close paren or punctuation         ($4)
  }ix

  # === Normalize endnote labels for <reflink> and <bibl>
  # @type [Regexp]
  BRACKETED_REFLINK_BIBL_REGEX = %r{
    (\[?\s*)                          # Opt. outer left square bracket     ($1)
      <(reflink|bibl)([^>]*)>         # Open tag name and attributes    ($2,$3)
        \[*\s*([a-z0-9-]+)\.?\s*\]*   # Note number (possibly bracketed)   ($4)
      </\s*\2\s*>                     # Close tag
    (\s*\]?)                          # Opt. outer right square bracket    ($5)
  }ix

  # === Create missing <bibl> entries.
  # @type [Regexp]
  MISSING_BIBL_REGEX = /
    (<blist(| [^>]*)>)                # <blist> with opt. attributes    ($1,$2)
    \s*                               # Optional space
    (<bibtext(| [^>]*)>)              # <bibtext> with opt. attributes  ($3,$4)
  /x

  # === Fix invalid reflink/bibl elements
  # @type [Regexp]
  REFLINK_BIBL_REGEX = %r{
    <(reflink|bibl)([^>]*)>           # Open tag name and attributes    ($1,$2)
      \s*(.*?)\s*                     # Note number                        ($3)
    </\s*\1\s*>                       # Close tag
  }ix

  # === Keep <reflink> elements enclosed in square brackets together
  # @type [Regexp]
  KEEP_ALL_REGEX = %r{
    \[
      \s*\[\s*(<reflink [^>]*>.*?</reflink>)\s*\]\s*
      (\s*[,-]+\s*\[\s*<reflink [^>]*>.*?</reflink>\s*\]\s*)*
    \]
  }ix

  # Apply changes to ensure that <reflink> and <bibl> elements appear as links
  # to each other.
  #
  # @param [String] content           String to modify.
  #
  # @return [String]
  #
  # === Examples
  #
  # @example <reflink> and <bibl> with missing <bibl> entries reconstructed
  #   /articles/a9h__133661700
  #
  # @example <reflink> and <bibl> with unreferenced <bibl> entries
  #   /articles/a9h__133661761
  #
  def render_fulltext_references!(content)
    bibl_node     = {}
    reflink_node  = {}
    reflink_count = bibl_count = 0

    # === Fix bogus <reflink> elements
    # Some PLoS ONE articles seem to have <reflink> elements generated on the
    # assumption that digits enclosed in parentheses are references, however
    # there are some cases where this is predictably incorrect.  In those cases
    # this section replaces the <reflink> element with its contents.
    content.gsub!(BOGUS_REFLINK_REGEX) do |match|
      lp_note_rp = [$1, $3, $4].map(&:presence)
      (lp_note_rp.first && lp_note_rp.last) ? lp_note_rp.join : match
    end

    # === Normalize endnote labels for <reflink> and <bibl>
    # Turn the reference number into a link to the element corresponding to
    # 'idref'.
    content.gsub!(BRACKETED_REFLINK_BIBL_REGEX) do
      lsb, tag_name, attr, number, rsb = $1, $2, attr_to_options($3), $4, $5
      if tag_name == 'reflink'
        reflink_count += 1
        index  = attr[:id]    ||= "ref#{reflink_count}"
        anchor = attr[:idref] ||= "bib#{number.tr('^0-9', '')}"
        reflink_node[index]   ||= anchor
        lsb  = lsb.presence
        rsb  = rsb.presence
        link = ft_ref_link(number, anchor)
      else
        bibl_count += 1
        index  = attr[:id]    ||= "bib#{bibl_count}"
        anchor = attr[:idref] ||= "ref#{number.tr('^0-9', '')}"
        bibl_node[index]      ||= anchor
        lsb  = '[' if lsb.blank?
        rsb  = ']' if rsb.blank?
        link = ft_ref_back(number, anchor)
      end
      [lsb, content_tag(tag_name, link, attr), rsb].join
    end

    # === Create missing <bibl> entries.
    # PLoS ONE in particular seems to create <bibl> entries only for the first
    # nine endnotes.  This portion finds places where <bibl> entries should
    # appear but are missing. If the entry is referenced by a <reflink> then
    # it will contain a link back to the reference; otherwise it will just
    # contain the entry number.
    content.gsub!(MISSING_BIBL_REGEX) do
      blist, bibtext = $1, $3
      bibl_count += 1
      index = id = "bib#{bibl_count}"
      reflink = reflink_node.find { |rid, aid| break rid if aid == index }
      bibl_node[index] = reflink || true
      bibl_opt = { id: id }
      bibl_opt[:idref] = reflink if reflink
      number = bibl_count.to_s
      number = ft_ref_back(number, reflink) if reflink
      [blist, '[', ft_tag(:bibl, number, bibl_opt), ']', bibtext].join
    end

    # === Fix invalid reflink/bibl elements
    # Correct both generated links and elements in the received content that
    # was erroneous.
    content.gsub!(REFLINK_BIBL_REGEX) do |match|
      start_tag, attr, number = $1, attr_to_options($2), $3
      table  = (start_tag == 'reflink') ? bibl_node : reflink_node
      anchor = attr[:idref]
      if table[anchor].present?
        match
      elsif number.include?('href=')
        ft_tag(start_tag, number.gsub(%r{^.*<a [^>]*>([^<]+)</a>.*$}, '\1'))
      else
        ft_tag(start_tag, number)
      end
    end

    # === Keep <reflink> elements enclosed in square brackets together
    # Eliminate nested square brackets (e.g. "[[1],[2]]" becomes "[1,2]").
    content.gsub!(KEEP_ALL_REGEX) do |match|
      match = match.gsub(/\s*[\[\]]+\s*/, '').gsub(/\s*(,)\s*/, '\1&thinsp;')
      ft_tag(:span, "[#{match}]".html_safe, class: 'keep-all')
    end

    content
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # Base path for arXiv URLs.
  #
  # @type [String]
  #
  ARXIV_BASE_URL = 'https://arxiv.org/abs'

  # Base path for arXiv URLs.
  #
  # @type [String]
  #
  DOI_BASE_URL = 'https://doi.org'

  # Known common URL shorteners; appearance of this pattern at the start of a
  # string can indicate the presence of a an implicit URL.  (Note that TinyURL
  # is not included because "tinyurl.com" will be matched via #URL_DOMAINS.)
  #
  # @type [Array<String>]
  #
  URL_DOMAINS = %w(
    com
    edu
    gov
    net
    org
  ).freeze

  # For use within a literal Regexp.
  #
  # @type [String]
  #
  URL_DOMAINS_PATTERN = URL_DOMAINS.join('|').gsub(/\./, '\\.').freeze

  # Known common URL shorteners; appearance of this pattern at the start of a
  # string can indicate the presence of a an implicit URL.  (Note that TinyURL
  # is not included because "tinyurl.com" will be matched via #URL_DOMAINS.)
  #
  # @type [Array<String>]
  #
  # Reference:
  # @see https://bit.do/list-of-url-shorteners.php
  #
  URL_SHORTENERS = %w(
    adf.ly
    bc.vc
    bit.do
    bit.ly
    cur.lv
    cutt.us
    db.tt
    goo.gl
    is.gd
    ity.im
    j.mp
    ow.ly
    qr.ae
    t.co
    tr.im
    u.to
    v.gd
    x.co
    youtu.be
    ✩.ws
    ➡.ws
  ).freeze

  # For use within a literal Regexp.
  #
  # @type [String]
  #
  URL_SHORTENERS_PATTERN = URL_SHORTENERS.join('|').gsub(/\./, '\\.').freeze

  # Pattern for the final character of a string recognizable as a URL.
  #
  # @type [String]
  #
  TERMINAL = %q{[^,;.!?)"'\s<]}

  # === Turn e-mail addresses into "mailto:" links
  # @type [Regexp]
  MAILTO_REGEX = /(?<!mailto:)([^@("'\s>]+@[^@"'\s<]+[^@,;.!?)"'\s<])/

  # === Link <img> element to its source
  # @type [Regexp]
  IMAGE_REGEX = %r{<img [^>]*src="([^"]+)"[^>]*>}i

  # === Turn explicit URLs into links
  # @type [Regexp]
  EXPLICIT_URL_REGEX = %r{(?<!=["'])(https?://[^)\s<]+#{TERMINAL})}i

  # === Turn implicit URLs into links
  #
  # [a] String beginning with "arXiv:"
  # [b] String beginning with "www."
  # [c] String beginning with "doi:" or "10."
  # [d] String beginning with "bit.ly/", "ow.ly/", etc.
  # [e] String beginning with hostname "*.com", "*.edu", etc.
  #
  # @type [Regexp]
  #
  IMPLICIT_URL_REGEX = %r{(?<=[^=][("'\s>])(
                                         arXiv:\s*[^\s<]+#{TERMINAL} | # [a]
                         www\.[^/?)"'\s<]+([/?][^)\s<]*)?#{TERMINAL} | # [b]
                   (doi:\s*)?10\.\d{4,}(\.\d+)*/[^"'\s<]*#{TERMINAL} | # [c]
                   (#{URL_SHORTENERS_PATTERN})/[^)"'\s<]+#{TERMINAL} | # [d]
    ([^/.("'\s>]+\.)+(#{URL_DOMAINS_PATTERN})([/?][^\s<]*#{TERMINAL})? # [e]
  )}ix

  # === Correct <a> elements that were already in the text
  # @type [Regexp]
  OVER_PROCESSED_URL_REGEX = %r{
    <a ([^>]+)>                         # Original href wrapped in a link  ($1)
      \s*<a [^>]+>\s*([^<]+)\s*</a>\s*  # Original label wrapped in a link ($2)
    </a>
  }ix

  # Apply changes to ensure that explicit and implicit URLs are presented as
  # clickable links.
  #
  # @param [String] content           String to modify.
  #
  # @return [String]
  #
  # @see self#ft_outlink
  # @see self#URL_SHORTENERS_PATTERN
  # @see self#URL_DOMAINS_PATTERN
  #
  # === Examples
  #
  # @example Many implicit URLs:
  #   /articles/f5h__127929267
  #
  # @example Many explicit URLs (and images):
  #   /articles/eric__EJ940121
  #
  # @example With "doi:" and "arXiv:" links:
  #   /articles/a9h__133661705
  #
  # @example Implied DOIs:
  #   /articles/a9h__133663752
  #
  # @example With <img> links
  #   /articles/f5h__32045913
  #
  def render_fulltext_links!(content)

    # === Turn e-mail addresses into "mailto:" links
    content.gsub!(MAILTO_REGEX) { email_link($1) }

    # === Link <img> element to its source
    content.gsub!(IMAGE_REGEX) { |match| ft_outlink(match, $1) }

    # === Turn explicit URLs into links
    # This (should) avoid touching URLs that included as the 'href' or 'src' of
    # existing HTML elements found in the content.
    content.gsub!(EXPLICIT_URL_REGEX) { ft_outlink($1, $1) }

    # === Turn implicit URLs into links
    # An implicit URL is not preceded by "http://" or "https://" but is clearly
    # a hostname (optionally followed by a path, optionally followed by URL
    # parameters).  Some implicit URLs will not be caught because of hostnames
    # that do not match the simplified heuristics used here.
    content.gsub!(IMPLICIT_URL_REGEX) do |match|
      label = match.sub(/^(arXiv:|doi:)\s*/i, '\1')
      url =
        case label
          when /^arXiv:(\d{4})\.?(.*)$/i then "#{ARXIV_BASE_URL}/#{$1}.#{$2}"
          when /^arXiv:(.*)$/i           then "#{ARXIV_BASE_URL}/#{$1}"
          when /^doi:(.*)$/i             then "#{DOI_BASE_URL}/#{$1}"
          when /^10\./                   then "#{DOI_BASE_URL}/#{label}"
          else                                "http://#{label}"
        end
      ft_outlink(label, url)
    end

    # === Correct <a> elements that were already in the text
    # The above mappings will turn an HTML link already in the text -- e.g.:
    # '<a href="URL">url</a>' -- into:
    # '<a href="URL"><a href="http://url">url</a></a>' -- or possibly:
    # '<a href="<a href="URL">URL</a>"><a href="http://url">url</a></a>'.
    # This section corrects that by re-assembling the original <a> linkage,
    # extracting the label from the inner <a> and the URL from the outer <a>
    # href (which may or may not have been erroneously wrapped in an <a>).
    content.gsub!(OVER_PROCESSED_URL_REGEX) do
      attr, label = attr_to_options($1), $2
      url = attr.delete(:href).to_s.gsub(%r{<a[^>]*>\s*([^<]+)\s*</a>}, '\1')
      ft_outlink(label, url, attr)
    end

    content
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # Generated external link in the fulltext.
  #
  # @param [String]    label          Assumed to be HTML-safe.
  # @param [String]    url
  # @param [Hash, nil] opt            Merged with EBSCO_OPTS.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def ft_outlink(label, url, opt = nil)
    label = label.to_s.html_safe
    url   = CGI.unescapeHTML(url)
    opt   = merge_html_options(EBSCO_OPTS, opt)
    outlink(label, url, opt)
  end

  # Generated link in the fulltext from <reflink> to <bibl>.
  #
  # @param [String]    label
  # @param [String]    anchor
  # @param [Hash, nil] opt            @see self#ft_anchor_link
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def ft_ref_link(label, anchor, opt = nil)
    html_options = { title: "Jump to note #{label}" }
    ft_anchor_link(label, anchor, merge_html_options!(html_options, opt))
  end

  # Generated link in the fulltext from <bibl> to <reflink>.
  #
  # @param [String]    label
  # @param [String]    anchor
  # @param [Hash, nil] opt            @see self#ft_anchor_link
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def ft_ref_back(label, anchor, opt = nil)
    html_options = { title: 'Jump back to text' }
    ft_anchor_link(label, anchor, merge_html_options!(html_options, opt))
  end

  # Generated link in the fulltext to a named location on the page.
  #
  # @param [String]    label
  # @param [String]    anchor
  # @param [Hash, nil] opt            @see self#ft_link
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def ft_anchor_link(label, anchor, opt = nil)
    anchor = '#' + anchor unless anchor.start_with?('#')
    ft_link(label, anchor, opt)
  end

  # Generated internal link in the fulltext.
  #
  # @param [String]    label          Assumed to be HTML-safe.
  # @param [String]    url
  # @param [Hash, nil] opt            Merged with EBSCO_OPTS.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def ft_link(label, url, opt = nil)
    label = label.to_s.html_safe
    opt   = merge_html_options(EBSCO_OPTS, opt)
    link_to(label, url, opt)
  end

  # Generated HTML element in the fulltext.
  #
  # @param [String, Symbol] tag
  # @param [String]         content   Assumed to be HTML-safe.
  # @param [Hash, nil]      opt       Merged with EBSCO_OPTS.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def ft_tag(tag, content, opt = nil)
    content = content.to_s.html_safe
    opt     = merge_html_options(EBSCO_OPTS, opt)
    content_tag(tag, content, opt)
  end

end

__loading_end(__FILE__)
